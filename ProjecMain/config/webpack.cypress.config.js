// Імпортуємо функцію `merge` з бібліотеки `webpack-merge`. 
// Вона дозволяє об'єднувати кілька конфігурацій Webpack в одну.
const { merge } = require('webpack-merge');

// Імпортуємо базову конфігурацію Webpack з файлу `webpack.config.js`.
// Цей файл містить спільні налаштування, які підходять для різних режимів.
const baseConfig = require('./webpack.config');

// Створюємо об'єкт `config`, що містить конфігурацію для середовища розробки.
const config = {
    // Вказуємо режим роботи Webpack як 'development', що оптимізує збірку для розробки.
    mode: 'development',

    // Налаштовуємо вихідні параметри збірки.
    output: {
        // Ім'я вихідного файлу, що буде створено після збірки. 
        // У цьому випадку файл називатиметься `bundle.js`.
        filename: 'bundle.js',
    },

    // Описуємо правила обробки файлів з використанням різних лоадерів (loader).
    module: {
        rules: [
            {
                // Застосовуємо це правило до файлів, що мають розширення `.css`.
                // `/\.css$/i` - регулярний вираз для перевірки файлів з розширенням `.css`.
                test: /\.css$/i,
                // Використовуємо лоадери для обробки CSS:
                use: [
                    // `style-loader` додає стилі до DOM через теги `<style>`.
                    'style-loader',
                    {
                        // Використовуємо `css-loader` для імпорту CSS у JavaScript-файли.
                        loader: 'css-loader',
                        options: {
                            modules: {
                                // Вмикаємо CSS-модулі в режимі 'local', що означає локальне ім'я класів.
                                mode: 'local',
                                // Налаштовуємо формат імені класу:
                                // `[name]` - ім'я файлу, `[local]` - оригінальне ім'я CSS-класу.
                                localIdentName: '[name]__[local]',
                                // `namedExport: false` означає, що імена класів не експортуються окремо.
                                // Якщо встановити `true`, то ім'я кожного класу буде доступне як окремий експорт.
                                namedExport: false,
                            },
                        },
                    },
                ],
            },
            {
                // Застосовуємо це правило до файлів з розширенням `.js` або `.jsx`.
                test: /\.jsx?$/,
                // Використовуємо `babel-loader` для трансформації сучасного JavaScript і JSX.
                use: [
                    {
                        loader: 'babel-loader',
                        options: {
                            // Використовуємо пресети Babel:
                            // `@babel/preset-env` - для трансформації сучасного JavaScript у сумісний код.
                            // `@babel/preset-react` - для трансформації JSX в JavaScript.
                            presets: ['@babel/preset-env', '@babel/preset-react'],
                            // Додаємо плагін `istanbul` для покриття коду тестами.
                            plugins: ['istanbul'],
                        },
                    },
                ],
            },
        ],
    },

    // Налаштування dev-сервера для середовища розробки.
    devServer: {
        // Вказуємо, що dev-сервер буде запускатися на порту 3000.
        port: 3000,
    },
};

// Експортуємо об'єднану конфігурацію, 
// використовуючи `merge` для поєднання базової конфігурації та специфічної для розробки.
module.exports = merge(baseConfig, config);

